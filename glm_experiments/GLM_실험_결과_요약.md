# GLM 시각적 평가 실험 결과

## 개요
이 문서는 ARC 문제에 대한 GLM-4.1V-9B-Thinking의 시각적 평가 실험 결과를 요약합니다. 예상 출력과 생성된 출력 간의 시각적 비교를 통해 GLM이 코드 실패를 분석하는 능력을 테스트했습니다.

**테스트 문제**: `2072aba6`
- **Success**: True (코드 실행 오류 없음)
- **Accuracy**: 0.0% (출력이 정답과 일치하지 않음)
- **설명**: "입력에는 회색 픽셀의 특정 패턴이 있는 3x3 그리드가 표시됩니다. 출력을 만들려면 패턴을 반복하여 6x6 그리드를 채우고 회색 픽셀을 체커보드 패턴으로 파란색과 빨간색으로 변경해야 합니다."

---

## 실험 1: 전체 이미지 이해

### 접근 방법
GLM에게 3개 열이 있는 단일 이미지 제시:
- 1열: 입력 그리드 (3x3)
- 2열: 예상 출력 그리드 (6x6)
- 3열: 생성된 출력 그리드 (6x6)

### 결과 요약

#### 프롬프트 1: 직접 평가
**질문**: "이미지를 보면 코드가 맞습니까, 틀립니까? 3열의 출력이 2열과 다른 이유는 무엇입니까?"

**GLM 분석**:
- **판정**: 코드가 **틀렸음**
- **주요 문제점**:
  1. **패턴 반복 오류**: 3×3 입력 패턴이 6×6 그리드를 채우도록 올바르게 반복되지 않음
  2. **체커보드 색상 할당 오류**: 회색 픽셀이 파란색/빨간색 교대 패턴으로 제대로 변환되지 않음
- **구체적 관찰사항**:
  - 생성된 출력의 패턴이 잘못 정렬될 수 있음
  - 인접한 셀이 교대하지 않고 같은 색상을 가지는 경우가 있음
  - 3×3 패턴의 2×2 타일링이 제대로 구현되지 않음

#### 프롬프트 2: 상세 패턴 분석
**질문**: "다음을 식별하세요: 1) 문제가 실제로 따르는 패턴은? 2) 코드가 구현한 패턴은? 3) 설명을 어떻게 변경해야 하나?"

**GLM 분석**:
- 각 입력의 실제 회색 픽셀 위치 분석 시작
- 3×3 그리드를 2×2번 반복하여 6×6을 만들어야 함을 식별
- 체커보드 패턴이 위치에 따라 색상을 교대해야 함을 언급
- 그러나 전체 분석을 완료하기 전에 응답이 중단됨

#### 프롬프트 3: 단계별 가이드
**질문**: "입력->예상 패턴을 기반으로 이 문제를 해결할 수정된 설명을 제안하세요."

**GLM 분석**:
- 예상 출력과 생성된 출력 간의 구체적 차이점 식별 시도
- 3×3 입력에서 회색 픽셀 위치 매핑 시작
- 예상 출력이 더 큰 그리드인 것으로 보임 (5×5 또는 7×7로 잘못 식별)
- 응답이 불완전했지만 상세한 위치별 분석을 보여줌

---

## 실험 2: 행 분리 분석

### 접근 방법
각 training example에 대해 별도 이미지 생성:
- 입력 | 예상 출력 | 생성된 출력

두 가지 방법으로 테스트:
1. **all_at_once**: 3개 이미지를 함께 전송
2. **sequential**: 이미지를 하나씩 전송

### 결과 요약

#### 접근법 1: 한 번에 모두
**프롬프트**: "모든 예제를 함께 보면서, 생성된 출력이 왜 잘못되었나요?"

**GLM 분석**:
- 각 입력의 회색 픽셀 위치 식별:
  - 입력 1: 회색 픽셀이 십자 모양 패턴 형성
  - 입력 2: 대각선상의 회색 픽셀 (1,1), (2,2), (3,3)
  - 입력 3: 다른 패턴의 회색 픽셀
- **주요 문제점**:
  1. 3×3 패턴의 잘못된 반복 (6×6으로 제대로 타일링되지 않음)
  2. 잘못된 색상 할당 (파란색/빨간색 위치가 예상과 일치하지 않음)
  3. 체커보드 패턴이 제대로 적용되지 않음
- 생성된 출력 2가 적절한 파란색/빨간색 교대 대신 "대부분 파란색"임을 언급

#### 접근법 2: 순차적 분석

**예제 1 분석**:
- 입력에서 5개의 회색 픽셀 식별: (1,1), (1,2), (2,1), (2,3), (3,2)
- 6×6으로 확장 시 각 3×3 블록이 동일한 패턴을 유지해야 함을 언급
- 구체적 오류 발견:
  - 생성된 출력의 첫 번째 셀이 검은색 대신 빨간색
  - 색상이 적절한 체커보드 교대를 따르지 않음
  - 패턴 반복이 잘못 정렬됨

**예제 2 분석**:
- 대각선 회색 픽셀 식별: (1,1), (2,2), (3,3)
- 6×6 그리드에서 이들이 매핑될 위치 계산:
  - 좌상단 블록: (1,1), (2,2), (3,3)
  - 우상단 블록: (1,4), (2,5), (3,6)
  - 좌하단 블록: (4,1), (5,2), (6,3)
  - 우하단 블록: (4,4), (5,5), (6,6)
- 체커보드 패턴 적용 분석 시작

**예제 3 분석**:
- 6개의 회색 픽셀 식별: (1,2), (1,3), (2,2), (2,3), (3,1), (3,2)
- 예상 vs 생성 출력 비교 시작
- 분석이 불완전함

---

## 주요 발견사항

### 1. 시각적 패턴 인식
GLM이 성공적으로 수행한 것:
- 3×3 입력의 회색 픽셀 위치 식별
- 6×6은 3×3의 2×2 타일링으로 생성되어야 함을 인식
- 체커보드 패턴(교대 색상) 개념 이해

### 2. 오류 감지 능력
GLM이 올바르게 식별한 것:
- 패턴 반복 실패
- 색상 할당 오류
- 체커보드 패턴 위반
- 구체적인 셀별 차이점

### 3. 분석 깊이
- GLM은 매우 상세한 위치별 분석 제공
- 예상 vs 생성을 비교하는 체계적 접근법 사용
- 입력에서 출력으로의 변환 논리 추적 시도

### 4. 관찰된 한계
- 일부 응답이 중단되거나 불완전함
- 그리드 차원에 대해 가끔 혼란 (6×6 대신 5×5 또는 7×7 언급)
- 때때로 상세한 셀별 분석에서 길을 잃음

---

## 결론

1. **GLM은 ARC 문제 분석을 위한 강력한 시각적 추론 능력을 보여줌**
2. **모델은 생성된 출력의 특정 패턴 변환 오류를 식별할 수 있음**
3. **순차적 분석(실험 2)**이 단일 이미지 분석보다 더 상세한 통찰력 제공
4. **GLM은 구조적 오류**(패턴 반복)와 **색상 매핑 오류**(체커보드 패턴) 모두 성공적으로 식별

## 권장사항

1. 더 상세한 오류 감지를 위해 순차적 분석 사용 고려
2. 프롬프트에 더 명확한 그리드 차원 정보 제공
3. 완전한 분석을 위해 토큰 제한 증가 필요할 수 있음
4. 다중 텐서 평가(실험 3)가 더 구조화된 분석을 제공할 수 있음

---

## 실험 3: 다중 텐서 평가

### 접근 방법
GLM에게 5개 차원에서 구조화된 평가를 요청:
1. 예제별 정확도
2. 색상 변환
3. 공간 변환
4. 패턴 인식
5. 구조적 무결성

### 결과 요약

#### 다중 텐서 평가
**프롬프트**: 5개 차원에 대한 상세 평가 요청

**GLM의 평가** (추정치):
1. **예제별 정확도**:
   - 예제 1: 70% 정확도
   - 예제 2: 60% 정확도
   - 예제 3: 65% 정확도
   - 평균: 65%

2. **색상 변환**:
   - 색상 매핑 정확성: 65%
   - 필요한 곳의 색상 보존: 80%
   - 새로운 색상 생성 정확도: 70%
   - 평균: 71.67%

3. **공간 변환**:
   - X축 변환: 75%
   - Y축 변환: 75%
   - 회전/반사 정확도: 80%
   - 크기/스케일 처리: 70%
   - 평균: 75%

4. **패턴 인식**:
   - 입력 패턴 감지: 80%
   - 규칙 적용 일관성: 65%
   - 엣지 케이스 처리: 70%
   - 평균: 71.67%

5. **구조적 무결성**:
   - 그리드 차원 정확성: YES (100%)
   - 객체 경계 보존: 75%
   - 연결성 유지: 70%
   - 평균: 81.67%

**종합 분석**:
- **전체 정확도**: 약 73%
- **주요 실패 차원**: 예제별 정확도 (65%)가 가장 낮음
- **제안된 수정사항**: 패턴 반복 로직과 체커보드 색상 할당 규칙 개선 필요

#### 전통적 평가
**프롬프트**: "코드가 맞습니까? TRUE 또는 FALSE"

**GLM의 답변**:
- **답**: FALSE
- **설명**: "생성된 출력이 주어진 입력에 대한 예상 출력과 일치하지 않습니다. 예를 들어, 입력 1에서 생성된 출력의 패턴과 색상 배열이 예상 출력과 다르므로 코드가 패턴을 올바르게 반복하고 체커보드 색상 변경을 적용하지 않음을 나타냅니다."

### 실험 3의 통찰

1. **구조화된 평가의 장점**:
   - 각 차원별로 구체적인 점수 제공
   - 문제의 어느 부분이 가장 실패했는지 명확히 식별
   - 개선이 필요한 구체적 영역 지적

2. **정량적 분석**:
   - GLM이 각 차원에 대해 구체적인 백분율 점수 제공
   - 가장 낮은 점수: 예제별 정확도 (65%)
   - 가장 높은 점수: 구조적 무결성 (81.67%)

3. **전통적 평가와의 비교**:
   - 전통적 평가는 단순히 TRUE/FALSE
   - 다중 텐서 평가는 훨씬 더 상세한 분석 제공

---

## 전체 실험 결론

1. **GLM의 시각적 분석 능력**:
   - 3가지 실험 모두에서 일관되게 코드의 오류를 정확히 식별
   - 패턴 반복과 색상 할당 문제를 구체적으로 지적

2. **실험별 장단점**:
   - **실험 1**: 전체적인 비교에 좋음
   - **실험 2**: 개별 예제 분석에 강점
   - **실험 3**: 정량적이고 구조화된 평가 제공

3. **ARC-LatentSeek 개선 방향**:
   - GLM의 다중 텐서 평가를 reward 함수에 통합 고려
   - 각 차원별 점수를 활용한 더 정교한 최적화 가능

---

## 실험 4: 코드 수정 능력 평가

### 접근 방법
GLM에게 실패하는 코드와 시각적 비교를 보여주고, 정답이 나오도록 코드를 수정하라고 요청

### 프롬프트
- 현재 실패하는 코드 제시
- 3열 비교 이미지 (입력/예상 출력/생성된 출력) 제공
- 코드가 왜 실패하는지 분석하고 수정된 버전 제공 요청

### 결과 요약

**GLM의 시도**:
- 여러 가지 수정 방법을 고민함
- 체커보드 패턴 로직을 수정하려 시도:
  - `(x + y) % 2 == 0` → `(i + j + x + y) % 2 == 0`
  - `(x + y) % 2 == (i + j) % 2`
- 그러나 최종적으로 원래 코드와 동일한 코드를 제출

**실행 결과**:
- **원래 코드 정확도**: 0.0%
- **수정된 코드 정확도**: 0.0%
- **개선**: 0.0%
- **결론**: ❌ GLM의 수정이 정확도를 개선하지 못함

### 실험 4의 분석

1. **코드 수정의 어려움**:
   - GLM은 문제를 이해하고 있으나 구체적인 수정 방법을 찾지 못함
   - 여러 체커보드 패턴 공식을 시도했지만 올바른 해결책에 도달하지 못함

2. **GLM의 한계**:
   - 시각적 패턴은 인식하지만 이를 코드로 변환하는 데 어려움
   - 실제 6x6 출력이 어떻게 생성되어야 하는지 정확히 파악하지 못함

3. **실패 원인 분석**:
   - GLM이 제안한 수정사항들이 실제 문제의 핵심을 해결하지 못함
   - 단순히 체커보드 패턴 공식만 바꾸는 것으로는 부족함
   - 실제로는 더 근본적인 패턴 변환 로직의 수정이 필요할 수 있음

---

## 전체 실험 총평

### 실험별 성과
1. **실험 1-3**: GLM은 시각적 분석에서 뛰어난 능력을 보임
   - 패턴 인식 ✅
   - 오류 위치 파악 ✅
   - 정성적 분석 ✅

2. **실험 4**: 코드 수정에서는 한계를 보임
   - 문제 이해 ✅
   - 구체적 해결책 제시 ❌
   - 실제 개선 ❌

### 주요 시사점
1. **GLM의 강점**: 시각적 패턴 분석과 오류 감지
2. **GLM의 약점**: 분석한 내용을 실제 작동하는 코드로 변환
3. **ARC-LatentSeek 활용 방안**: 
   - GLM을 평가자로 사용하는 것은 효과적
   - 하지만 코드 생성은 별도의 모델이 담당하는 것이 좋음

---

*모든 실험이 완료되었습니다.*